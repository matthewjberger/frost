// Comprehensive Frost Evaluation

// 1. Fibonacci with memoization-style iteration
fib :: fn(n: i64) -> i64 {
    if (n < 2) {
        return n;
    }
    mut a := 0;
    mut b := 1;
    for i in 2..n+1 {
        mut temp := a + b;
        a = b;
        b = temp;
    }
    return b;
}

print(fib(10));
print(fib(20));

// 2. Higher-order functions
map_int :: fn(f: fn(i64) -> i64, n: i64) -> i64 {
    return f(n);
}

double :: fn(x: i64) -> i64 { x * 2 }
square :: fn(x: i64) -> i64 { x * x }

print(map_int(double, 5));
print(map_int(square, 5));

// 3. Currying
curry_add :: fn(a: i64) -> fn(i64) -> i64 {
    return fn(b: i64) -> i64 { a + b };
}

add5 := curry_add(5);
add10 := curry_add(10);
print(add5(3));
print(add10(3));

// 4. Defer for cleanup
test_defer :: fn() -> i64 {
    mut result := 0;
    defer result = result + 1;
    defer result = result * 10;
    result = 5;
    return result;
}
print(test_defer());
